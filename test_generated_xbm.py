import numpy as np
from PIL import Image

w, h = 50, 28
data = [
    0x00, 0x00, 0xE0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40,
    0x0F, 0xE0, 0x05, 0x00, 0x00, 0x00, 0x40, 0x0F, 0xE0, 0x05, 0x00, 0x00,
    0x00, 0x40, 0x3F, 0xF8, 0x05, 0x00, 0x00, 0x00, 0x80, 0xFE, 0xFE, 0x02,
    0x00, 0x00, 0x00, 0x00, 0xFD, 0x7F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x81,
    0x03, 0x01, 0x00, 0x00, 0x00, 0x80, 0x91, 0x12, 0x03, 0x00, 0x00, 0x00,
    0x80, 0x9C, 0x72, 0x02, 0x00, 0x00, 0x00, 0x80, 0x5F, 0xF5, 0x03, 0x00,
    0x00, 0x00, 0x00, 0x50, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x15,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x15, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x15, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xA0, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
]

# matrice vuota
img = np.zeros((h, w), np.uint8)
bytes_per_row = (w + 7) // 8

# interpretazione “classica” orizzontale/lsb
for y in range(h):
    for bx in range(bytes_per_row):
        idx = y * bytes_per_row + bx
        if idx < len(data):
            byte = data[idx]
            for b in range(8):
                x = bx * 8 + b
                if x < w:
                    img[y, x] = 255 * ((byte >> b) & 1)

variants = {
    "original": img,
}

for name, m in variants.items():
    Image.fromarray(m).show(title=name)
